# 如何快速基于 Webpack 解决前端工程化问题，创造团队价值（KPI）

# TL;DR

笔者通过解决已有项目中存在的开发体验问题，进而总结出快速基于 Webpack 解决项目问题的方法论。

因为我并不精通 Webpack，所以“快速”二字是指快速试错，以解决问题为目的。而不是快速成为 Webpack 大师。

本文包括：

1. 搭建快速试错的环境
2. 试错方案一：实现自定义 loader
3. 试错方案二：实现自定义 resolve-plugin
4. 试错方案三：实现自定义 babel-plugin
5. 试错方案四：实现 webpack-plugin 和 fork-ts-checker 插件的 Hook

## 背景

在笔者的业务场景中，后端通过 Thrift idl 定义接口的入参和返回值。前端使用工具将 idl 转换成 TypeScript 文件后，业务代码便能使用后端接口的类型定义了。

在该场景下，前端通过一个配置文件维护后端 idl 的版本。当切换分支引起配置文件发生变化，前端启动服务后，会先看到 TS 报错。新人看到报错后，往往一脸茫然，最后只能请教导师。导师看到报错后，就会告诉新人“你执行下某某命令，重新将 idl 转换成 TS 就可以了”。

这就是存在的问题，解决该问题有个最简单的做法，就是启动服务的同时，监听配置文件，一旦配置文件发生改变，就生成新的 TS 文件。但是这个方案存在两个问题：

1. 因为监听配置文件与 Webpack 构建流程不相关，所以在转换任务完成之前，Webpack 可能已经编译完并报错了。出现这种情况时，仍然会对开发者造成困扰。
2. 启动服务时，需要对所有 idl 进行转换，会增加开发的启动时间。

### 期望解决方案

最好的解决方案要满足：

1. 启动时判断转换后的 TS 是否存在或是否为最新，如果为否则自动生成 TS。
2. 配置文件改变后，自动生成新的 TS。
3. 协调转换 idl 的任务和 Webpack 的构建流程，保证 idl 转换完成前 webpack 不报错。
4. 根据业务代码，仅对使用到的 idl 文件进行转换。

# 搭建快速试错的环境

## git worktree 单独开项目目录

在进行技术重构的同时，往往还需要兼顾业务。如果在同一个目录下进行技术重构和业务开发，存在以下问题：

1. 对 Webpack 流程的修改往往会引起整个项目打包出错，切换分支后，需要重新安装依赖。
2. 修改了 Webpack 流程后，偶尔需要清理缓存后再重启服务，比如：清理 ESLint 缓存。
3. 因为不精通 Webpack 生态，所以经常需要修改源码进行测试。但重新安装依赖将丢失在 node_modules 中的修改。
4. IDE 上某些功能需要按照技术重构和业务开发进行区分，比如：断点和书签。在技术重构时关心的断点和书签往往与业务开发时不同。如果在同一个目录进行重构和业务开发，它们的断点和书签就会混在一起，影响开发体验。

因此，为了提升开发体验，建议将 Webpack 相关工作单独放一个目录中进行。

可以使用 `git clone` 将项目克隆到新目录。但建议使用 [`git worktree`](https://git-scm.com/docs/git-worktree) 命令，因为它不需要再次克隆项目，这在项目很大时可以节约很多时间。

```sh
# 在项目根目录执行
git worktree add ../for-webpack

# 切换到 for-webpack 进行开发
cd ../for-webpack
```

## 简化项目代码

每次修改了 Webpack 流程的相关代码后，都需要重启服务才能生效。真实项目的业务代码非常多，每次启动项目至少要花费几十秒，而且 Debug 模式下时间更长。如果每次修改代码后都要等几十秒，那么开发效率就太低了。

为了提高试错效率，建议修改项目的入口文件，即 Webpack 配置中的 `entry` 参数。在入口文件中，使用最少的代码覆盖关心的问题。例如，在我要解决的问题中，只需要入口文件有以下代码即可。

```js
import { A } from "~idl/a"
```

<!-- 1. 不修改 Webpack 版本和配置，保证 Webpack 的运行环境与真实环境一致。毕竟将解决方案整合进已有项目才是目的。
2. 项目小，不仅能提升启动速度，也能更聚焦到需要解决的问题上。 -->

# 方案一：自定义 loader

因为要实现按需构建，所以实现自定义 loader 是最直接的想法。增加 webpack 配置如下：

```js
const config = {
  module: {
    rules: [
      {
        // 配置 idl-loader 去拦截 '~idl/xxx'，
        // 其中 ~idl 是 resolve.alias 中配置的别名
        test: path.resolve(__dirname, "src/idl"),
        use: ["idl-loader"],
      },
    ],
  },

  resolveLoader: {
    // 在当前目录搜索 loader
    modules: ["node_modules", "."],
  },
}
```

创建 `./idl-loader` 文件，内容如下：

```js
module.exports = function(source) {
  console.log("source")
  return source
}
```

在 `console.log("source")` 打个断点，启动项目。
